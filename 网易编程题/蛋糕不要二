/*首先欧氏距离为2的，只有在同行或同列并且相隔为2。
然后就是最大化填充了。
分三类讨论：(分整除4，整除2，奇数等几种情况讨论即可)
1）每4×4个格子可放8个；
2）剩余的1~3行×(W/4*4)列+剩余的1~3列×(H/4*4)行；
3）最后1~9个格子，又可分2小类：如果是3*3，则可以放2*2个+最下角的一个 ；
  否则1*1，1*2(2*1)，2*2。
*/


/*
现在我们可以从下面的数据中找规律。
（1）行为奇数、列为奇数。1*1->1  1*3->2  1*5->3
                         3*1->2  3*3->5  3*5->8......
                         规律为:  W*H/2+1
(2)行为奇数，列为偶数。1*2->2 3*2->4  5*2->6
                       1*4->2  3*4->6  5*4->10.....
                       此时发现，能被4整除和能被2整除的规律不同。
   当能被4整除时，W*H/2。当能被2整除时，（行+1）*宽/2；
（3）行为偶数，列为奇数；
（4）行为偶数，列为奇数；
规律同上，进行合并；
核心代码如下：
 if(W%4==0 || H%4==0)
      result=W*H/2;
 else if(W%2==0 && H%2==0) result=(W*H/4+ 1) * 2; else result=W*H/2+1;
 */

import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int W,H,result;
        W = sc.nextInt();
        H = sc.nextInt();
        if(W%4==0 || H%4==0)
            result=W*H/2;
       else if(W%2==0 && H%2==0) 
    	   result=(W*H/4+ 1) * 2; 
       else 
    	   result=W*H/2+1;
        
        System.out.println(result);
        sc.close();
    }
 
}